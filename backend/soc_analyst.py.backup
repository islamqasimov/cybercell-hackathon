"""
Unified SOC Analyst - Combines Traditional + ML Analysis
"""
from sqlalchemy.orm import Session
from main import SessionLocal, Alert, RuleRecommendation, DetectionRule, IncidentReport
from datetime import timedelta, datetime
import re
from collections import Counter
from ai_engine import AIEngine
import json

# Try to import ML Cyber Consultant
try:
    from cyber_consultant import CyberConsultant, run_cyber_consultant_analysis
    ML_AVAILABLE = True
    print("âœ“ ML Cyber Consultant available")
except ImportError:
    ML_AVAILABLE = False
    print("âš  ML Cyber Consultant not available - using traditional analysis only")


async def analyze_and_recommend(alert_id: int):
    """
    Unified analysis: Traditional SIEM + ML Cyber Consultant
    """
    db = SessionLocal()
    try:
        alert = db.query(Alert).get(alert_id)
        if not alert:
            print(f"Alert {alert_id} not found")
            return
        
        print(f"\n{'='*70}")
        print(f"ðŸ¤– ANALYZING Alert #{alert_id}")
        print(f"{'='*70}")
        
        # STEP 1: Traditional rule-based analysis
        print("\n[Traditional Analysis] Pattern matching...")
        traditional_analysis = await perform_traditional_analysis(alert, db)
        
        # STEP 2: ML Cyber Consultant (if available)
        ml_report = None
        if ML_AVAILABLE:
            print("\n[ML Analysis] Running Cyber Consultant...")
            try:
                ml_report = await run_cyber_consultant_analysis(alert_id)
                if ml_report:
                    print("âœ“ ML analysis complete")
                else:
                    print("âš  ML analysis returned no data")
            except Exception as e:
                print(f"âš  ML analysis failed: {e}")
                import traceback
                traceback.print_exc()
        else:
            print("\n[ML Analysis] Skipped - ML not available")
        
        # STEP 3: Generate combined recommendations
        await generate_combined_recommendations(alert, traditional_analysis, ml_report, db)
        
        db.commit()
        
        print(f"\n{'='*70}")
        print("âœ“ Analysis complete")
        print(f"{'='*70}\n")
        
    except Exception as e:
        print(f"Error analyzing alert {alert_id}: {e}")
        import traceback
        traceback.print_exc()
        db.rollback()
    finally:
        db.close()


async def perform_traditional_analysis(alert: Alert, db) -> dict:
    """Traditional SIEM-style analysis"""
    alert_data = {
        'id': alert.id,
        'rule_id': alert.rule_id,
        'rule_description': alert.rule_description,
        'host': alert.host,
        'severity': alert.severity,
        'timestamp': alert.timestamp.isoformat(),
        'raw_data': alert.raw_data or {}
    }
    
    recent_cutoff = datetime.utcnow() - timedelta(hours=24)
    similar_alerts = db.query(Alert).filter(
        Alert.rule_id == alert.rule_id,
        Alert.timestamp >= recent_cutoff
    ).all()
    
    alert_data['similar_count'] = len(similar_alerts)
    
    try:
        analysis = await AIEngine.analyze_alert_with_llm(alert_data)
    except Exception as e:
        print(f"  AI analysis unavailable: {e}")
        analysis = generate_fallback_analysis(alert_data, similar_alerts)
    
    return analysis


async def generate_combined_recommendations(alert: Alert, traditional: dict, 
                                          ml_report: dict, db):
    """Generate recommendations from both analyses"""
    print("\nðŸŽ¯ Generating recommendations...")
    
    created_count = 0
    
    # Traditional rule recommendations
    if traditional and 'recommendations' in traditional:
        for rec_data in traditional['recommendations']:
            if await create_rule_recommendation(rec_data, alert, db):
                created_count += 1
    
    # ML-based recommendations (if available)
    if ml_report and 'strategic_recommendations' in ml_report:
        strategic_rules = await convert_strategic_to_rules(
            ml_report['strategic_recommendations'],
            ml_report.get('behavioral_analysis', {}),
            ml_report.get('threat_predictions', {}),
            alert
        )
        
        for rule_rec in strategic_rules:
            if await create_rule_recommendation(rule_rec, alert, db):
                created_count += 1
    
    print(f"âœ“ Created {created_count} new recommendations")


async def create_rule_recommendation(rec_data: dict, alert: Alert, db) -> bool:
    """Create recommendation with deduplication"""
    rule_id = rec_data['rule_id']
    action = rec_data['action']
    
    existing = db.query(RuleRecommendation).filter(
        RuleRecommendation.rule_id == rule_id,
        RuleRecommendation.action == action,
        RuleRecommendation.applied == False
    ).first()
    
    if existing:
        existing.confidence = max(existing.confidence, rec_data.get('confidence', 85))
        existing.evidence_count += 1
        return False
    
    if action == "CREATE":
        existing_rule = db.query(DetectionRule).filter(
            DetectionRule.rule_id == rule_id
        ).first()
        if existing_rule:
            return False
    
    rec = RuleRecommendation(
        action=action,
        rule_id=rule_id,
        reason=rec_data.get('reason', 'ML-generated recommendation'),
        current_pattern=rec_data.get('current_pattern'),
        suggested_pattern=rec_data.get('suggested_pattern', '.*'),
        severity=rec_data.get('severity', 'medium'),
        confidence=rec_data.get('confidence', 85),
        evidence_count=1
    )
    db.add(rec)
    return True


async def convert_strategic_to_rules(strategic_recs: list, behavioral: dict, 
                                    predictions: dict, alert: Alert) -> list:
    """Convert ML strategic recommendations to detection rules"""
    rules = []
    
    for rec in strategic_recs:
        title = rec['title'].lower()
        
        if 'block' in title and 'ip' in title:
            source_ip = alert.raw_data.get('source_ip', 'unknown')
            if source_ip != 'unknown':
                rules.append({
                    'action': 'CREATE',
                    'rule_id': f'ML-BLOCK-IP-{source_ip.replace(".", "-")}',
                    'reason': f'ML Consultant: {rec["title"]}',
                    'suggested_pattern': f'source_ip:{source_ip}',
                    'severity': 'critical',
                    'confidence': 95
                })
        
        elif 'monitor' in title or 'logging' in title:
            rules.append({
                'action': 'CREATE',
                'rule_id': f'ML-MONITOR-{alert.host.upper()}',
                'reason': f'ML Behavioral Anomaly Detected',
                'suggested_pattern': f'host:{alert.host}',
                'severity': 'medium',
                'confidence': 80
            })
    
    # Add anomaly-based rules
    if behavioral.get('is_anomalous'):
        deviations = behavioral.get('deviations', {})
        
        if 'request_length' in deviations and deviations['request_length'].get('is_outlier'):
            rules.append({
                'action': 'CREATE',
                'rule_id': f'ML-ANOMALY-LENGTH',
                'reason': f'ML detected unusual request length (z-score: {deviations["request_length"]["z_score"]:.1f})',
                'suggested_pattern': 'request_size:>10000',
                'severity': 'high',
                'confidence': 88
            })
    
    return rules


def generate_fallback_analysis(alert_data: dict, similar_alerts: list) -> dict:
    """Fallback pattern-based analysis"""
    rule_id = alert_data.get('rule_id', '')
    rule_desc = alert_data.get('rule_description', '').lower()
    raw_data = alert_data.get('raw_data', {})
    log = raw_data.get('log', '')
    
    recommendations = []
    attack_analysis = "Pattern-based analysis performed. "
    
    if 'sql' in rule_desc or 'injection' in rule_desc:
        attack_analysis += "SQL injection attack detected. "
        
        if '--' in log:
            recommendations.append({
                "action": "CREATE",
                "rule_id": "SQLI-COMMENT-001",
                "reason": "SQL comment injection detected (--)",
                "suggested_pattern": r"['\"]--",
                "severity": "high",
                "confidence": 85
            })
    
    elif 'xss' in rule_desc or 'script' in rule_desc:
        attack_analysis += "XSS attack detected. "
        
        if '<script' in log.lower():
            recommendations.append({
                "action": "CREATE",
                "rule_id": "XSS-SCRIPT-001",
                "reason": "Script tag injection detected",
                "suggested_pattern": r"<script[^>]*>",
                "severity": "medium",
                "confidence": 85
            })
    
    if len(similar_alerts) > 50:
        recommendations.append({
            "action": "DISABLE",
            "rule_id": rule_id,
            "reason": f"High false positive rate ({len(similar_alerts)} alerts in 24h)",
            "severity": "low",
            "confidence": 85
        })
    
    return {
        "attack_analysis": attack_analysis,
        "recommendations": recommendations
    }
